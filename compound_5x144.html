<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Compound of 5 × 144 Polyhedra</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: system-ui, sans-serif; background: #0a0a15; color: #eee; overflow: hidden; }
        #controls {
            position: fixed; top: 15px; left: 15px;
            background: rgba(10, 10, 20, 0.95); padding: 15px; border-radius: 8px;
            z-index: 100; width: 320px; max-height: 90vh; overflow-y: auto;
            border: 1px solid rgba(100, 150, 255, 0.2);
        }
        h1 { font-size: 1.2rem; color: #7af; margin-bottom: 5px; }
        .subtitle { font-size: 0.75rem; color: #888; margin-bottom: 15px; }
        h2 { font-size: 0.8rem; color: #aaa; margin: 12px 0 8px 0; border-top: 1px solid #333; padding-top: 10px; }
        .control-row { margin: 6px 0; font-size: 0.8rem; }
        .control-row label { display: flex; align-items: center; gap: 8px; cursor: pointer; }
        .stats { font-family: monospace; font-size: 0.7rem; margin: 10px 0; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 4px; line-height: 1.6; }
        .highlight { color: #7af; font-weight: bold; }
        .gold { color: #ffd700; }
        #canvas-container { width: 100vw; height: 100vh; }
        .legend { margin-top: 8px; }
        .legend-item { display: flex; align-items: center; gap: 6px; margin: 4px 0; font-size: 0.75rem; }
        .legend-color { width: 16px; height: 16px; border-radius: 3px; }
        button { background: #335; color: #aef; border: 1px solid #446; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.75rem; margin: 3px; }
        button:hover { background: #446; }
    </style>
</head>
<body>
    <div id="controls">
        <h1>Compound of 5 × 144</h1>
        <p class="subtitle">Five 144-polyhedra in icosahedral arrangement</p>
        
        <div class="stats" id="stats">Loading...</div>
        
        <h2>Display</h2>
        <div class="control-row">
            <label><input type="checkbox" id="showFaces" checked> Show Faces</label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="showEdges" checked> Show Edges</label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="showVertices"> Show Vertices</label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="autoRotate" checked> Auto Rotate</label>
        </div>
        
        <h2>Individual 144s</h2>
        <div class="control-row">
            <label><input type="checkbox" id="show0" checked> <span style="color:#66ff66">144 #1 (0°)</span></label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="show1" checked> <span style="color:#ffff66">144 #2 (72°)</span></label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="show2" checked> <span style="color:#cc88ff">144 #3 (144°)</span></label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="show3" checked> <span style="color:#ff9966">144 #4 (216°)</span></label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="show4" checked> <span style="color:#66ccff">144 #5 (288°)</span></label>
        </div>
        
        <h2>Octahedra (120)</h2>
        <div class="control-row">
            <label><input type="checkbox" id="showOcta0"> <span style="color:#66ff66">Octa #1 (0°)</span></label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="showOcta1"> <span style="color:#ffff66">Octa #2 (72°)</span></label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="showOcta2"> <span style="color:#cc88ff">Octa #3 (144°)</span></label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="showOcta3"> <span style="color:#ff9966">Octa #4 (216°)</span></label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="showOcta4"> <span style="color:#66ccff">Octa #5 (288°)</span></label>
        </div>
        
        <h2>Color Legend</h2>
        <div class="legend">
            <div class="legend-item"><div class="legend-color" style="background:#66ff66"></div>144 #1 (0°)</div>
            <div class="legend-item"><div class="legend-color" style="background:#ffff66"></div>144 #2 (72°)</div>
            <div class="legend-item"><div class="legend-color" style="background:#cc88ff"></div>144 #3 (144°)</div>
            <div class="legend-item"><div class="legend-color" style="background:#ff9966"></div>144 #4 (216°)</div>
            <div class="legend-item"><div class="legend-color" style="background:#66ccff"></div>144 #5 (288°)</div>
        </div>
    </div>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const PHI = (1 + Math.sqrt(5)) / 2;
        const SCALE = 4;
        const COLORS = [0x66ff66, 0xffff66, 0xcc88ff, 0xff9966, 0x66ccff];
        
        // Utility functions
        function isFCC(x, y, z) { return (x + y + z) % 2 === 0; }
        function toUnit(fcc) { return [fcc[0]/SCALE, fcc[1]/SCALE, fcc[2]/SCALE]; }
        function vec3(a) { return new THREE.Vector3(a[0], a[1], a[2]); }
        function add(a, b) { return [a[0]+b[0], a[1]+b[1], a[2]+b[2]]; }
        function sub(a, b) { return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
        function mul(v, s) { return [v[0]*s, v[1]*s, v[2]*s]; }
        function dot(a, b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
        function len(v) { return Math.sqrt(dot(v, v)); }
        function norm(v) { const l = len(v); return l ? mul(v, 1/l) : [0,0,0]; }
        function avg(...vs) {
            const n = vs.length;
            return [vs.reduce((s,v) => s+v[0], 0)/n, vs.reduce((s,v) => s+v[1], 0)/n, vs.reduce((s,v) => s+v[2], 0)/n];
        }
        
        // Octahedron geometry for 144
        const OUTER = [[4,0,0],[-4,0,0],[0,4,0],[0,-4,0],[0,0,4],[0,0,-4]];
        const FACES = [[0,2,4],[0,4,3],[0,3,5],[0,5,2],[1,4,2],[1,3,4],[1,5,3],[1,2,5]];
        
        // Find nearest FCC point
        function nearestFCC(pt) {
            let best = null, bestD = Infinity;
            for (let dx = -2; dx <= 2; dx++) {
                for (let dy = -2; dy <= 2; dy++) {
                    for (let dz = -2; dz <= 2; dz++) {
                        const c = [Math.round(pt[0])+dx, Math.round(pt[1])+dy, Math.round(pt[2])+dz];
                        if (!isFCC(c[0], c[1], c[2])) continue;
                        const d = len(sub(c, pt));
                        if (d < bestD) { bestD = d; best = c; }
                    }
                }
            }
            return best;
        }
        
        // Find face center from r²=12 shell
        function findFaceCenter(A, B, C, normal) {
            const candidates = [
                [2,2,2], [-2,-2,-2], [2,2,-2], [2,-2,2], [-2,2,2],
                [2,-2,-2], [-2,2,-2], [-2,-2,2]
            ];
            
            let best = null, bestAlign = -Infinity;
            for (const c of candidates) {
                const cNorm = norm(c);
                const align = dot(cNorm, normal);
                if (align > bestAlign) {
                    bestAlign = align;
                    best = c;
                }
            }
            
            if (best && bestAlign > 0.9) return best;
            
            const flatCenter = avg(A, B, C);
            return nearestFCC(flatCenter);
        }
        
        // Build a single 144 polyhedron
        function build144() {
            const vertices = [];
            const triangles = [];
            const vertexMap = {};
            
            function addV(v) {
                const key = v.map(Math.round).join(',');
                if (!(key in vertexMap)) {
                    vertexMap[key] = vertices.length;
                    vertices.push(v.map(Math.round));
                }
                return vertexMap[key];
            }
            
            for (const face of FACES) {
                const A = OUTER[face[0]];
                const B = OUTER[face[1]];
                const C = OUTER[face[2]];
                const faceNormal = norm(avg(A, B, C));
                
                const mAB = avg(A, B);
                const mBC = avg(B, C);
                const mCA = avg(C, A);
                
                let O = findFaceCenter(A, B, C, faceNormal);
                
                const L1 = [
                    [A, mAB, O], [mAB, B, O], [B, mBC, O],
                    [mBC, C, O], [C, mCA, O], [mCA, A, O]
                ];
                
                for (const [P, Q, R] of L1) {
                    const centFlat = avg(P, Q, R);
                    const centPushed = add(centFlat, mul(faceNormal, 0.5));
                    const cent = nearestFCC(centPushed);
                    
                    const pI = addV(P);
                    const qI = addV(Q);
                    const rI = addV(R);
                    const cI = addV(cent);
                    
                    triangles.push([pI, qI, cI]);
                    triangles.push([qI, rI, cI]);
                    triangles.push([rI, pI, cI]);
                }
            }
            
            return { vertices, triangles };
        }
        
        // Build the 144 once
        const base144 = build144();
        const baseVerticesUnit = base144.vertices.map(toUnit);
        
        // Three.js setup
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a15);
        
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 5);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);
        
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        const light1 = new THREE.DirectionalLight(0xffffff, 0.7);
        light1.position.set(5, 5, 5);
        scene.add(light1);
        const light2 = new THREE.DirectionalLight(0xffffff, 0.3);
        light2.position.set(-5, -5, 5);
        scene.add(light2);
        
        const mainGroup = new THREE.Group();
        scene.add(mainGroup);
        
        // Icosahedral 5-fold axis: (0, 1, φ) normalized
        const axis = new THREE.Vector3(0, 1, PHI).normalize();
        
        // Create 5 copies of the 144
        const polyhedra = [];
        const edgeGroups = [];
        const vertexGroups = [];
        
        // Also create 5 octahedra (matching the 120 compound)
        const octahedra = [];
        const octaEdgeGroups = [];
        
        // Unit octahedron vertices (same scale as 144's outer octahedron)
        const OCTA_VERTS = [
            new THREE.Vector3(1, 0, 0),
            new THREE.Vector3(-1, 0, 0),
            new THREE.Vector3(0, 1, 0),
            new THREE.Vector3(0, -1, 0),
            new THREE.Vector3(0, 0, 1),
            new THREE.Vector3(0, 0, -1)
        ];
        
        const OCTA_FACES = [
            [0, 2, 4], [0, 4, 3], [0, 3, 5], [0, 5, 2],
            [1, 4, 2], [1, 3, 4], [1, 5, 3], [1, 2, 5]
        ];
        
        const OCTA_EDGES = [
            [0, 2], [0, 3], [0, 4], [0, 5],
            [1, 2], [1, 3], [1, 4], [1, 5],
            [2, 4], [4, 3], [3, 5], [5, 2]
        ];
        
        for (let i = 0; i < 5; i++) {
            const angle = i * 2 * Math.PI / 5;
            
            // Create rotation quaternion
            const quat = new THREE.Quaternion().setFromAxisAngle(axis, angle);
            
            // Face mesh
            const faceGeom = new THREE.BufferGeometry();
            const positions = [];
            
            for (const tri of base144.triangles) {
                for (const idx of tri) {
                    const v = baseVerticesUnit[idx];
                    const vec = new THREE.Vector3(v[0], v[1], v[2]);
                    vec.applyQuaternion(quat);
                    positions.push(vec.x, vec.y, vec.z);
                }
            }
            
            faceGeom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            faceGeom.computeVertexNormals();
            
            const faceMat = new THREE.MeshStandardMaterial({
                color: COLORS[i],
                side: THREE.DoubleSide,
                transparent: false,
                opacity: 1.0,
                roughness: 0.5,
                polygonOffset: true,
                polygonOffsetFactor: i,
                polygonOffsetUnits: i
            });
            
            const faceMesh = new THREE.Mesh(faceGeom, faceMat);
            mainGroup.add(faceMesh);
            polyhedra.push(faceMesh);
            
            // Edges
            const edgeGroup = new THREE.Group();
            const edgeMat = new THREE.LineBasicMaterial({ color: 0x000000 });
            
            for (const tri of base144.triangles) {
                const pts = [];
                for (const idx of tri) {
                    const v = baseVerticesUnit[idx];
                    const vec = new THREE.Vector3(v[0], v[1], v[2]);
                    vec.applyQuaternion(quat);
                    pts.push(vec);
                }
                pts.push(pts[0].clone());
                
                const lineGeom = new THREE.BufferGeometry().setFromPoints(pts);
                const line = new THREE.Line(lineGeom, edgeMat);
                edgeGroup.add(line);
            }
            
            mainGroup.add(edgeGroup);
            edgeGroups.push(edgeGroup);
            
            // Vertices
            const vertGroup = new THREE.Group();
            const vertGeom = new THREE.SphereGeometry(0.02, 8, 8);
            const vertMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            
            for (const v of baseVerticesUnit) {
                const vec = new THREE.Vector3(v[0], v[1], v[2]);
                vec.applyQuaternion(quat);
                const sphere = new THREE.Mesh(vertGeom, vertMat);
                sphere.position.copy(vec);
                vertGroup.add(sphere);
            }
            
            vertGroup.visible = false;
            mainGroup.add(vertGroup);
            vertexGroups.push(vertGroup);
            
            // Create octahedron for this rotation
            const octaGeom = new THREE.BufferGeometry();
            const octaPositions = [];
            
            for (const face of OCTA_FACES) {
                for (const idx of face) {
                    const v = OCTA_VERTS[idx].clone();
                    v.applyQuaternion(quat);
                    octaPositions.push(v.x, v.y, v.z);
                }
            }
            
            octaGeom.setAttribute('position', new THREE.Float32BufferAttribute(octaPositions, 3));
            octaGeom.computeVertexNormals();
            
            const octaMat = new THREE.MeshStandardMaterial({
                color: COLORS[i],
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.5,
                roughness: 0.5
            });
            
            const octaMesh = new THREE.Mesh(octaGeom, octaMat);
            octaMesh.visible = false;
            mainGroup.add(octaMesh);
            octahedra.push(octaMesh);
            
            // Octahedron edges
            const octaEdgeGroup = new THREE.Group();
            const octaEdgeMat = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
            
            for (const edge of OCTA_EDGES) {
                const p1 = OCTA_VERTS[edge[0]].clone().applyQuaternion(quat);
                const p2 = OCTA_VERTS[edge[1]].clone().applyQuaternion(quat);
                const lineGeom = new THREE.BufferGeometry().setFromPoints([p1, p2]);
                const line = new THREE.Line(lineGeom, octaEdgeMat);
                octaEdgeGroup.add(line);
            }
            
            octaEdgeGroup.visible = false;
            mainGroup.add(octaEdgeGroup);
            octaEdgeGroups.push(octaEdgeGroup);
        }
        
        // Calculate statistics
        function calculateStats() {
            const allVertices = [];
            const seen = new Set();
            
            for (let i = 0; i < 5; i++) {
                const angle = i * 2 * Math.PI / 5;
                const quat = new THREE.Quaternion().setFromAxisAngle(axis, angle);
                
                for (const v of baseVerticesUnit) {
                    const vec = new THREE.Vector3(v[0], v[1], v[2]);
                    vec.applyQuaternion(quat);
                    
                    const key = `${vec.x.toFixed(6)},${vec.y.toFixed(6)},${vec.z.toFixed(6)}`;
                    if (!seen.has(key)) {
                        seen.add(key);
                        allVertices.push(vec);
                    }
                }
            }
            
            return {
                totalFaces: 5 * 144,
                totalVerticesRaw: 5 * base144.vertices.length,
                uniqueVertices: allVertices.length,
                coincidences: 5 * base144.vertices.length - allVertices.length
            };
        }
        
        const stats = calculateStats();
        document.getElementById('stats').innerHTML = `
            <span class="highlight">Faces:</span> 5 × 144 = <span class="gold">${stats.totalFaces}</span><br>
            <span class="highlight">Raw vertices:</span> 5 × ${base144.vertices.length} = ${stats.totalVerticesRaw}<br>
            <span class="highlight">Unique vertices:</span> <span class="gold">${stats.uniqueVertices}</span><br>
            <span class="highlight">Coincidences:</span> ${stats.coincidences}
        `;
        
        console.log("Base 144 has", base144.vertices.length, "vertices and", base144.triangles.length, "triangles");
        console.log("Compound stats:", stats);
        
        // Controls
        document.getElementById('showFaces').addEventListener('change', (e) => {
            polyhedra.forEach(p => p.visible = e.target.checked);
        });
        
        document.getElementById('showEdges').addEventListener('change', (e) => {
            edgeGroups.forEach(g => g.visible = e.target.checked);
        });
        
        document.getElementById('showVertices').addEventListener('change', (e) => {
            vertexGroups.forEach(g => g.visible = e.target.checked);
        });
        
        for (let i = 0; i < 5; i++) {
            document.getElementById(`show${i}`).addEventListener('change', (e) => {
                polyhedra[i].visible = e.target.checked && document.getElementById('showFaces').checked;
                edgeGroups[i].visible = e.target.checked && document.getElementById('showEdges').checked;
                vertexGroups[i].visible = e.target.checked && document.getElementById('showVertices').checked;
            });
            
            document.getElementById(`showOcta${i}`).addEventListener('change', (e) => {
                octahedra[i].visible = e.target.checked;
                octaEdgeGroups[i].visible = e.target.checked;
            });
        }
        
        // Mouse controls
        let isDragging = false;
        let prevMouse = { x: 0, y: 0 };
        
        container.addEventListener('mousedown', (e) => {
            isDragging = true;
            prevMouse = { x: e.clientX, y: e.clientY };
        });
        
        container.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - prevMouse.x;
                const dy = e.clientY - prevMouse.y;
                mainGroup.rotation.y += dx * 0.01;
                mainGroup.rotation.x += dy * 0.01;
                prevMouse = { x: e.clientX, y: e.clientY };
            }
        });
        
        container.addEventListener('mouseup', () => isDragging = false);
        container.addEventListener('mouseleave', () => isDragging = false);
        
        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            camera.position.multiplyScalar(1 + e.deltaY * 0.001);
        }, { passive: false });
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Animation
        function animate() {
            requestAnimationFrame(animate);
            
            if (document.getElementById('autoRotate').checked && !isDragging) {
                mainGroup.rotation.y += 0.005;
            }
            
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>
