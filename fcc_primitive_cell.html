<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FCC Primitive Cell</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: system-ui, sans-serif; background: #0a0a12; color: #eee; overflow: hidden; }
        #controls {
            position: fixed; top: 15px; left: 15px;
            background: rgba(18, 18, 26, 0.95); padding: 15px; border-radius: 8px;
            z-index: 100; width: 280px;
        }
        h1 { font-size: 1rem; color: #7af; margin-bottom: 12px; }
        .control-row { margin: 8px 0; font-size: 0.8rem; }
        .control-row label { display: flex; align-items: center; gap: 8px; }
        input[type="checkbox"] { margin: 0; }
        .info { font-size: 0.75rem; color: #888; margin-top: 12px; line-height: 1.6; }
        .color-dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; margin-right: 6px; }
        .color-line { width: 20px; height: 3px; display: inline-block; margin-right: 6px; }
        #canvas-container { width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <div id="controls">
        <h1>FCC Primitive Cell</h1>
        
        <div class="control-row">
            <label><input type="checkbox" id="autoRotate" checked> Auto Rotate</label>
        </div>
        
        <div class="control-row">
            <label><input type="checkbox" id="showPrimitive" checked> Primitive Cell (rhombohedron)</label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="showConventional" checked> Conventional Cell (cube)</label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="showBasisVectors" checked> Basis Vectors</label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="showAllFCC"> Nearby FCC Points</label>
        </div>
        
        <div class="info">
            <strong>Primitive Basis Vectors:</strong><br>
            <span class="color-line" style="background:#ff4444"></span><strong>a₁</strong> = ½(0, 1, 1)<br>
            <span class="color-line" style="background:#44ff44"></span><strong>a₂</strong> = ½(1, 0, 1)<br>
            <span class="color-line" style="background:#4444ff"></span><strong>a₃</strong> = ½(1, 1, 0)<br><br>
            
            <strong>Primitive cell:</strong> rhombohedron<br>
            Contains exactly <strong>1 lattice point</strong><br><br>
            
            <strong>Conventional cell:</strong> cube<br>
            Contains <strong>4 lattice points</strong>
        </div>
    </div>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Primitive basis vectors (for conventional lattice constant a=1)
        const a1 = [0, 0.5, 0.5];
        const a2 = [0.5, 0, 0.5];
        const a3 = [0.5, 0.5, 0];
        
        // The 4 vertices of the primitive cell (rhombohedron)
        // Starting from origin, add combinations of basis vectors
        const primitiveVerts = [
            [0, 0, 0],                                          // origin
            a1,                                                  // a1
            a2,                                                  // a2
            a3,                                                  // a3
            [a1[0]+a2[0], a1[1]+a2[1], a1[2]+a2[2]],           // a1+a2
            [a1[0]+a3[0], a1[1]+a3[1], a1[2]+a3[2]],           // a1+a3
            [a2[0]+a3[0], a2[1]+a3[1], a2[2]+a3[2]],           // a2+a3
            [a1[0]+a2[0]+a3[0], a1[1]+a2[1]+a3[1], a1[2]+a2[2]+a3[2]]  // a1+a2+a3
        ];
        
        // Edges of the rhombohedron (parallelepiped)
        const primitiveEdges = [
            // From origin
            [0, 1], [0, 2], [0, 3],
            // From a1
            [1, 4], [1, 5],
            // From a2
            [2, 4], [2, 6],
            // From a3
            [3, 5], [3, 6],
            // To a1+a2+a3
            [4, 7], [5, 7], [6, 7]
        ];
        
        // Generate FCC points
        function generateFCC(range) {
            const points = [];
            for (let i = -range; i <= range; i++) {
                for (let j = -range; j <= range; j++) {
                    for (let k = -range; k <= range; k++) {
                        if ((i + j + k) % 2 === 0) {
                            points.push([i * 0.5, j * 0.5, k * 0.5]);
                        }
                    }
                }
            }
            return points;
        }
        
        // Three.js setup
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a12);
        
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(2, 1.5, 2.5);
        camera.lookAt(0.5, 0.5, 0.5);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);
        
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const light1 = new THREE.DirectionalLight(0xffffff, 0.8);
        light1.position.set(5, 5, 5);
        scene.add(light1);
        
        const mainGroup = new THREE.Group();
        scene.add(mainGroup);
        
        function rebuild() {
            while (mainGroup.children.length) mainGroup.remove(mainGroup.children[0]);
            
            const showPrimitive = document.getElementById('showPrimitive').checked;
            const showConventional = document.getElementById('showConventional').checked;
            const showBasis = document.getElementById('showBasisVectors').checked;
            const showAllFCC = document.getElementById('showAllFCC').checked;
            
            // Conventional cubic cell
            if (showConventional) {
                const cubeEdges = [
                    [[0,0,0], [1,0,0]], [[1,0,0], [1,1,0]], [[1,1,0], [0,1,0]], [[0,1,0], [0,0,0]],
                    [[0,0,1], [1,0,1]], [[1,0,1], [1,1,1]], [[1,1,1], [0,1,1]], [[0,1,1], [0,0,1]],
                    [[0,0,0], [0,0,1]], [[1,0,0], [1,0,1]], [[1,1,0], [1,1,1]], [[0,1,0], [0,1,1]]
                ];
                const cubeMat = new THREE.LineBasicMaterial({ color: 0x666666, transparent: true, opacity: 0.5 });
                for (const [p1, p2] of cubeEdges) {
                    const geom = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(...p1), new THREE.Vector3(...p2)
                    ]);
                    mainGroup.add(new THREE.Line(geom, cubeMat));
                }
            }
            
            // Primitive cell (rhombohedron)
            if (showPrimitive) {
                const primMat = new THREE.LineBasicMaterial({ color: 0xffaa00, linewidth: 2 });
                for (const [i, j] of primitiveEdges) {
                    const geom = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(...primitiveVerts[i]),
                        new THREE.Vector3(...primitiveVerts[j])
                    ]);
                    mainGroup.add(new THREE.Line(geom, primMat));
                }
                
                // Highlight the origin point (the ONE lattice point in primitive cell)
                const sphereGeom = new THREE.SphereGeometry(0.06, 24, 24);
                const sphereMat = new THREE.MeshStandardMaterial({ color: 0xffaa00 });
                const sphere = new THREE.Mesh(sphereGeom, sphereMat);
                sphere.position.set(0, 0, 0);
                mainGroup.add(sphere);
            }
            
            // Basis vectors as arrows
            if (showBasis) {
                const vectors = [
                    { v: a1, color: 0xff4444, label: 'a₁' },
                    { v: a2, color: 0x44ff44, label: 'a₂' },
                    { v: a3, color: 0x4444ff, label: 'a₃' }
                ];
                
                for (const { v, color } of vectors) {
                    const dir = new THREE.Vector3(...v).normalize();
                    const length = Math.sqrt(v[0]**2 + v[1]**2 + v[2]**2);
                    const arrow = new THREE.ArrowHelper(dir, new THREE.Vector3(0, 0, 0), length, color, 0.08, 0.04);
                    mainGroup.add(arrow);
                }
            }
            
            // All nearby FCC points
            if (showAllFCC) {
                const fccPoints = generateFCC(3);
                const sphereGeom = new THREE.SphereGeometry(0.03, 16, 16);
                const sphereMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
                
                for (const p of fccPoints) {
                    // Only show points near the cells we're displaying
                    if (p[0] >= -0.3 && p[0] <= 1.3 && 
                        p[1] >= -0.3 && p[1] <= 1.3 && 
                        p[2] >= -0.3 && p[2] <= 1.3) {
                        const sphere = new THREE.Mesh(sphereGeom, sphereMat);
                        sphere.position.set(...p);
                        mainGroup.add(sphere);
                    }
                }
            }
        }
        
        rebuild();
        
        document.querySelectorAll('input').forEach(el => {
            el.addEventListener('change', rebuild);
        });
        
        // Mouse controls
        let isDragging = false;
        let prevMouse = { x: 0, y: 0 };
        const pivot = new THREE.Vector3(0.5, 0.5, 0.5);
        
        container.addEventListener('mousedown', e => {
            isDragging = true;
            prevMouse = { x: e.clientX, y: e.clientY };
        });
        
        container.addEventListener('mousemove', e => {
            if (isDragging) {
                mainGroup.position.sub(pivot);
                mainGroup.rotation.y += (e.clientX - prevMouse.x) * 0.01;
                mainGroup.rotation.x += (e.clientY - prevMouse.y) * 0.01;
                mainGroup.position.add(pivot);
                prevMouse = { x: e.clientX, y: e.clientY };
            }
        });
        
        container.addEventListener('mouseup', () => isDragging = false);
        container.addEventListener('mouseleave', () => isDragging = false);
        
        container.addEventListener('wheel', e => {
            e.preventDefault();
            camera.position.sub(pivot);
            camera.position.multiplyScalar(1 + e.deltaY * 0.001);
            camera.position.add(pivot);
        }, { passive: false });
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        function animate() {
            requestAnimationFrame(animate);
            if (document.getElementById('autoRotate').checked && !isDragging) {
                mainGroup.position.sub(pivot);
                mainGroup.rotation.y += 0.005;
                mainGroup.position.add(pivot);
            }
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>
