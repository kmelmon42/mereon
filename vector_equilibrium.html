<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector Equilibrium (Cuboctahedron)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: system-ui, sans-serif; background: #0a0a12; color: #eee; overflow: hidden; }
        #controls {
            position: fixed; top: 15px; left: 15px;
            background: rgba(18, 18, 26, 0.95); padding: 15px; border-radius: 8px;
            z-index: 100; width: 260px;
        }
        h1 { font-size: 1.1rem; color: #7af; margin-bottom: 12px; }
        h2 { font-size: 0.85rem; color: #aaa; margin: 12px 0 6px 0; border-top: 1px solid #333; padding-top: 10px; }
        .control-row { margin: 6px 0; font-size: 0.8rem; }
        .control-row label { display: flex; align-items: center; gap: 8px; }
        input[type="checkbox"] { margin: 0; }
        .info { font-size: 0.7rem; color: #888; margin-top: 12px; line-height: 1.5; }
        .color-box { width: 12px; height: 12px; display: inline-block; border-radius: 2px; margin-right: 4px; }
        #canvas-container { width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <div id="controls">
        <h1>Vector Equilibrium</h1>
        
        <div class="control-row">
            <label><input type="checkbox" id="autoRotate" checked> Auto Rotate</label>
        </div>
        
        <h2>Display Elements</h2>
        <div class="control-row">
            <label><input type="checkbox" id="showVertexSpheres" checked> 12 Vertex Spheres</label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="showNuclearSphere"> Nuclear Sphere (for context)</label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="showEdges" checked> 24 Edges</label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="showRadii"> 12 Radial Vectors (for context)</label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="showTriFaces" checked> <span class="color-box" style="background:#ff6666"></span>8 Triangle Faces</label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="showSquareFaces" checked> <span class="color-box" style="background:#6666ff"></span>6 Square Faces</label>
        </div>
        
        <div class="info">
            <strong>Vector Equilibrium (VE)</strong><br>
            • 12 vertices<br>
            • 24 edges (all equal)<br>
            • 14 faces (8 triangles + 6 squares)<br>
            • Volume = 20 (tetrahedron = 1)<br><br>
            The VE arises from 12 spheres closest-packed around a center. Toggle "Nuclear Sphere" and "Radial Vectors" to see that context.<br><br>
            Unique property: radii = edge length
        </div>
    </div>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Vector Equilibrium (Cuboctahedron) vertices
        // 12 vertices at permutations of (±1, ±1, 0)
        const VE_VERTICES = [
            [1, 1, 0], [1, -1, 0], [-1, 1, 0], [-1, -1, 0],
            [1, 0, 1], [1, 0, -1], [-1, 0, 1], [-1, 0, -1],
            [0, 1, 1], [0, 1, -1], [0, -1, 1], [0, -1, -1]
        ];
        
        // Normalize to unit edge length
        // Current edge length is sqrt(2), so divide by sqrt(2)
        const scale = 1 / Math.sqrt(2);
        const vertices = VE_VERTICES.map(v => [v[0] * scale, v[1] * scale, v[2] * scale]);
        
        // 8 triangular faces (at cube corners)
        const triFaces = [
            [0, 4, 8],   // +x+y+z octant
            [0, 9, 5],   // +x+y-z
            [1, 5, 11],  // +x-y-z
            [1, 10, 4],  // +x-y+z
            [2, 8, 6],   // -x+y+z
            [2, 7, 9],   // -x+y-z
            [3, 6, 10],  // -x-y+z
            [3, 11, 7]   // -x-y-z
        ];
        
        // 6 square faces (at cube face centers)
        const squareFaces = [
            [0, 4, 1, 5],   // +x face
            [2, 7, 3, 6],   // -x face
            [0, 8, 2, 9],   // +y face
            [1, 11, 3, 10], // -y face
            [4, 6, 10, 8],  // +z face (reordered for correct winding)
            [5, 9, 7, 11]   // -z face
        ];
        
        // 24 edges
        const edges = [
            // Edges around +x square
            [0, 4], [4, 1], [1, 5], [5, 0],
            // Edges around -x square
            [2, 6], [6, 3], [3, 7], [7, 2],
            // Edges around +y square
            [0, 8], [8, 2], [2, 9], [9, 0],
            // Edges around -y square
            [1, 10], [10, 3], [3, 11], [11, 1],
            // Edges around +z square
            [4, 8], [8, 6], [6, 10], [10, 4],
            // Edges around -z square
            [5, 9], [9, 7], [7, 11], [11, 5]
        ];
        
        // Three.js setup
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a12);
        
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(2.5, 2, 3);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);
        
        // Lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const light1 = new THREE.DirectionalLight(0xffffff, 0.8);
        light1.position.set(5, 5, 5);
        scene.add(light1);
        const light2 = new THREE.DirectionalLight(0xffffff, 0.3);
        light2.position.set(-5, -3, -5);
        scene.add(light2);
        
        const mainGroup = new THREE.Group();
        scene.add(mainGroup);
        
        // Sphere radius (for close-packing visualization)
        // Edge length = 1 (after scaling), so sphere radius = 0.5
        const sphereRadius = 0.5;
        
        function rebuild() {
            while (mainGroup.children.length) mainGroup.remove(mainGroup.children[0]);
            
            // Nuclear sphere
            if (document.getElementById('showNuclearSphere').checked) {
                const nuclearGeom = new THREE.SphereGeometry(sphereRadius, 32, 32);
                const nuclearMat = new THREE.MeshStandardMaterial({
                    color: 0xffdd44,
                    transparent: true,
                    opacity: 0.6,
                    roughness: 0.3,
                    metalness: 0.1
                });
                const nuclear = new THREE.Mesh(nuclearGeom, nuclearMat);
                mainGroup.add(nuclear);
            }
            
            // Vertex spheres (12)
            if (document.getElementById('showVertexSpheres').checked) {
                const vertexGeom = new THREE.SphereGeometry(sphereRadius, 24, 24);
                const vertexMat = new THREE.MeshStandardMaterial({
                    color: 0x44aaff,
                    transparent: true,
                    opacity: 0.5,
                    roughness: 0.3,
                    metalness: 0.1
                });
                
                for (const v of vertices) {
                    const sphere = new THREE.Mesh(vertexGeom, vertexMat);
                    sphere.position.set(v[0], v[1], v[2]);
                    mainGroup.add(sphere);
                }
            }
            
            // Edges (24)
            if (document.getElementById('showEdges').checked) {
                const edgeMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
                
                for (const [i, j] of edges) {
                    const points = [
                        new THREE.Vector3(...vertices[i]),
                        new THREE.Vector3(...vertices[j])
                    ];
                    const geom = new THREE.BufferGeometry().setFromPoints(points);
                    mainGroup.add(new THREE.Line(geom, edgeMat));
                }
            }
            
            // Radial vectors (12)
            if (document.getElementById('showRadii').checked) {
                const radiiMat = new THREE.LineBasicMaterial({ color: 0x44ff44, linewidth: 2 });
                
                for (const v of vertices) {
                    const points = [
                        new THREE.Vector3(0, 0, 0),
                        new THREE.Vector3(...v)
                    ];
                    const geom = new THREE.BufferGeometry().setFromPoints(points);
                    mainGroup.add(new THREE.Line(geom, radiiMat));
                }
            }
            
            // Triangle faces (8)
            if (document.getElementById('showTriFaces').checked) {
                const triMat = new THREE.MeshStandardMaterial({
                    color: 0xff6666,
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide,
                    roughness: 0.5
                });
                
                for (const face of triFaces) {
                    const geom = new THREE.BufferGeometry();
                    const positions = [];
                    for (const idx of face) {
                        positions.push(...vertices[idx]);
                    }
                    geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                    geom.computeVertexNormals();
                    mainGroup.add(new THREE.Mesh(geom, triMat));
                }
            }
            
            // Square faces (6)
            if (document.getElementById('showSquareFaces').checked) {
                const squareMat = new THREE.MeshStandardMaterial({
                    color: 0x6666ff,
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide,
                    roughness: 0.5
                });
                
                for (const face of squareFaces) {
                    // Split square into 2 triangles
                    const geom = new THREE.BufferGeometry();
                    const positions = [
                        ...vertices[face[0]], ...vertices[face[1]], ...vertices[face[2]],
                        ...vertices[face[0]], ...vertices[face[2]], ...vertices[face[3]]
                    ];
                    geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                    geom.computeVertexNormals();
                    mainGroup.add(new THREE.Mesh(geom, squareMat));
                }
            }
        }
        
        rebuild();
        
        // Event listeners
        document.querySelectorAll('input').forEach(el => {
            el.addEventListener('change', rebuild);
        });
        
        // Mouse controls
        let isDragging = false;
        let prevMouse = { x: 0, y: 0 };
        
        container.addEventListener('mousedown', e => {
            isDragging = true;
            prevMouse = { x: e.clientX, y: e.clientY };
        });
        
        container.addEventListener('mousemove', e => {
            if (isDragging) {
                const dx = e.clientX - prevMouse.x;
                const dy = e.clientY - prevMouse.y;
                mainGroup.rotation.y += dx * 0.01;
                mainGroup.rotation.x += dy * 0.01;
                prevMouse = { x: e.clientX, y: e.clientY };
            }
        });
        
        container.addEventListener('mouseup', () => isDragging = false);
        container.addEventListener('mouseleave', () => isDragging = false);
        
        container.addEventListener('wheel', e => {
            e.preventDefault();
            camera.position.multiplyScalar(1 + e.deltaY * 0.001);
        }, { passive: false });
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Animation
        function animate() {
            requestAnimationFrame(animate);
            
            if (document.getElementById('autoRotate').checked && !isDragging) {
                mainGroup.rotation.y += 0.005;
            }
            
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>
