<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>144 Polyhedron - Three Triangle Types</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: system-ui, sans-serif; background: #1a1a2e; color: #eee; overflow: hidden; }
        #controls {
            position: fixed; top: 15px; left: 15px;
            background: rgba(18, 18, 26, 0.95); padding: 15px; border-radius: 8px;
            z-index: 100; width: 340px; max-height: 90vh; overflow-y: auto;
        }
        h1 { font-size: 1.1rem; color: #7af; margin-bottom: 8px; }
        h2 { font-size: 0.85rem; color: #aaa; margin: 12px 0 6px 0; border-top: 1px solid #333; padding-top: 10px; }
        .control-row { margin: 6px 0; font-size: 0.8rem; }
        .control-row label { display: flex; align-items: center; gap: 8px; cursor: pointer; }
        .info { font-size: 0.75rem; color: #888; margin-top: 8px; line-height: 1.5; }
        .highlight { color: #7af; font-weight: bold; }
        #canvas-container { width: 100vw; height: 100vh; }
        .type-box { 
            padding: 10px; margin: 8px 0; border-radius: 6px; 
            border-left: 4px solid;
        }
        .type1 { background: rgba(102, 255, 102, 0.15); border-color: #66ff66; }
        .type2 { background: rgba(102, 102, 255, 0.15); border-color: #6666ff; }
        .type3 { background: rgba(255, 102, 102, 0.15); border-color: #ff6666; }
        .type-title { font-weight: bold; margin-bottom: 4px; }
        .type1 .type-title { color: #66ff66; }
        .type2 .type-title { color: #6666ff; }
        .type3 .type-title { color: #ff6666; }
        .edge-info { font-family: monospace; font-size: 0.7rem; color: #ccc; }
    </style>
</head>
<body>
    <div id="controls">
        <h1>144 Polyhedron - Triangle Types</h1>
        <div class="info">
            <span class="highlight">144 triangles</span> in 3 distinct types<br>
            <span class="highlight">48 triangles</span> of each type
        </div>
        
        <h2>Display Options</h2>
        <div class="control-row">
            <label><input type="checkbox" id="showEdges" checked> Show Edges</label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="showOuterOcta"> Show Outer Octahedron</label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="autoRotate" checked> Auto Rotate</label>
        </div>
        
        <h2>Triangle Types</h2>
        <div class="control-row">
            <label><input type="checkbox" id="showType1" checked> <span style="color:#66ff66">Type 1 (48)</span></label>
        </div>
        <div class="type-box type1">
            <div class="type-title">Type 1: Scalene</div>
            <div class="edge-info">Edges: √2, √6, 2√2<br>Ratios: 1 : √3 : 2</div>
        </div>
        
        <div class="control-row">
            <label><input type="checkbox" id="showType2" checked> <span style="color:#6666ff">Type 2 (48)</span></label>
        </div>
        <div class="type-box type2">
            <div class="type-title">Type 2: Isoceles (45-45-90)</div>
            <div class="edge-info">Edges: √2, √2, 2<br>Ratios: 1 : 1 : √2</div>
        </div>
        
        <div class="control-row">
            <label><input type="checkbox" id="showType3" checked> <span style="color:#ff6666">Type 3 (48)</span></label>
        </div>
        <div class="type-box type3">
            <div class="type-title">Type 3: Scalene</div>
            <div class="edge-info">Edges: √2, √6, 2√3<br>Ratios: 1 : √3 : √6</div>
        </div>
    </div>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const SCALE = 4;
        
        function isFCC(x, y, z) { return (x + y + z) % 2 === 0; }
        function toUnit(fcc) { return [fcc[0]/SCALE, fcc[1]/SCALE, fcc[2]/SCALE]; }
        function vec3(a) { return new THREE.Vector3(a[0], a[1], a[2]); }
        function add(a, b) { return [a[0]+b[0], a[1]+b[1], a[2]+b[2]]; }
        function sub(a, b) { return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
        function mul(v, s) { return [v[0]*s, v[1]*s, v[2]*s]; }
        function dot(a, b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
        function len(v) { return Math.sqrt(dot(v, v)); }
        function norm(v) { const l = len(v); return l ? mul(v, 1/l) : [0,0,0]; }
        function avg(...vs) {
            const n = vs.length;
            return [vs.reduce((s,v) => s+v[0], 0)/n, vs.reduce((s,v) => s+v[1], 0)/n, vs.reduce((s,v) => s+v[2], 0)/n];
        }
        function dist(a, b) { return len(sub(a, b)); }
        
        // Octahedron
        const OUTER = [[4,0,0],[-4,0,0],[0,4,0],[0,-4,0],[0,0,4],[0,0,-4]];
        const FACES = [[0,2,4],[0,4,3],[0,3,5],[0,5,2],[1,4,2],[1,3,4],[1,5,3],[1,2,5]];
        const EDGES = [[0,2],[0,3],[0,4],[0,5],[1,2],[1,3],[1,4],[1,5],[2,4],[4,3],[3,5],[5,2]];
        
        function nearestFCC(pt) {
            let best = null, bestD = Infinity;
            for (let dx = -2; dx <= 2; dx++) {
                for (let dy = -2; dy <= 2; dy++) {
                    for (let dz = -2; dz <= 2; dz++) {
                        const c = [Math.round(pt[0])+dx, Math.round(pt[1])+dy, Math.round(pt[2])+dz];
                        if (!isFCC(c[0], c[1], c[2])) continue;
                        const d = len(sub(c, pt));
                        if (d < bestD) { bestD = d; best = c; }
                    }
                }
            }
            return best;
        }
        
        function classifyTriangle(p, q, r) {
            // Get sorted edge lengths
            const edges = [dist(p, q), dist(q, r), dist(r, p)].sort((a,b) => a-b);
            
            const sqrt2 = Math.sqrt(2);
            const sqrt6 = Math.sqrt(6);
            const sqrt12 = 2 * Math.sqrt(3);
            
            // Type 1: √2, √6, 2√2 (scalene)
            if (Math.abs(edges[0] - sqrt2) < 0.01 && 
                Math.abs(edges[1] - sqrt6) < 0.01 && 
                Math.abs(edges[2] - 2*sqrt2) < 0.01) {
                return 1;
            }
            
            // Type 2: √2, √2, 2 (isoceles 45-45-90)
            if (Math.abs(edges[0] - sqrt2) < 0.01 && 
                Math.abs(edges[1] - sqrt2) < 0.01 && 
                Math.abs(edges[2] - 2) < 0.01) {
                return 2;
            }
            
            // Type 3: √2, √6, 2√3 (scalene)
            if (Math.abs(edges[0] - sqrt2) < 0.01 && 
                Math.abs(edges[1] - sqrt6) < 0.01 && 
                Math.abs(edges[2] - sqrt12) < 0.01) {
                return 3;
            }
            
            console.log("Unknown triangle type:", edges);
            return 0;
        }
        
        // Build 144 with triangle type classification
        function build144() {
            const vertices = [];
            const triangles = []; // { verts: [i,j,k], type: 1|2|3 }
            const vertexMap = {};
            
            function addV(v) {
                const key = v.map(Math.round).join(',');
                if (!(key in vertexMap)) {
                    vertexMap[key] = vertices.length;
                    vertices.push(v.map(Math.round));
                }
                return vertexMap[key];
            }
            
            function findFaceCenter(A, B, C, normal) {
                const candidates = [
                    [2,2,2], [-2,-2,-2], [2,2,-2], [2,-2,2], [-2,2,2],
                    [2,-2,-2], [-2,2,-2], [-2,-2,2]
                ];
                
                let best = null, bestAlign = -Infinity;
                for (const c of candidates) {
                    const cNorm = norm(c);
                    const align = dot(cNorm, normal);
                    if (align > bestAlign) {
                        bestAlign = align;
                        best = c;
                    }
                }
                
                if (best && bestAlign > 0.9) return best;
                return nearestFCC(avg(A, B, C));
            }
            
            for (const face of FACES) {
                const A = OUTER[face[0]];
                const B = OUTER[face[1]];
                const C = OUTER[face[2]];
                const faceNormal = norm(avg(A, B, C));
                
                const mAB = avg(A, B);
                const mBC = avg(B, C);
                const mCA = avg(C, A);
                
                let O = findFaceCenter(A, B, C, faceNormal);
                
                const L1 = [
                    [A, mAB, O], [mAB, B, O], [B, mBC, O],
                    [mBC, C, O], [C, mCA, O], [mCA, A, O]
                ];
                
                for (const [P, Q, R] of L1) {
                    const centFlat = avg(P, Q, R);
                    const centPushed = add(centFlat, mul(faceNormal, 0.5));
                    const cent = nearestFCC(centPushed);
                    
                    const pI = addV(P);
                    const qI = addV(Q);
                    const rI = addV(R);
                    const cI = addV(cent);
                    
                    // Three triangles per L1
                    const tri1 = [P, Q, cent];
                    const tri2 = [Q, R, cent];
                    const tri3 = [R, P, cent];
                    
                    triangles.push({ verts: [pI, qI, cI], type: classifyTriangle(...tri1) });
                    triangles.push({ verts: [qI, rI, cI], type: classifyTriangle(...tri2) });
                    triangles.push({ verts: [rI, pI, cI], type: classifyTriangle(...tri3) });
                }
            }
            
            return { vertices, triangles };
        }
        
        // Three.js setup
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 4);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);
        
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const light = new THREE.DirectionalLight(0xffffff, 0.7);
        light.position.set(5, 5, 5);
        scene.add(light);
        const light2 = new THREE.DirectionalLight(0xffffff, 0.3);
        light2.position.set(-5, -3, 5);
        scene.add(light2);
        
        const mainGroup = new THREE.Group();
        scene.add(mainGroup);
        
        // Build geometry
        const { vertices, triangles } = build144();
        const verticesUnit = vertices.map(toUnit);
        
        // Count types
        const typeCounts = [0, 0, 0, 0];
        triangles.forEach(t => typeCounts[t.type]++);
        console.log("Triangle counts by type:", typeCounts);
        
        // Materials
        const materials = {
            type1: new THREE.MeshStandardMaterial({ 
                color: 0x66ff66, side: THREE.DoubleSide, 
                transparent: true, opacity: 0.85, roughness: 0.5 
            }),
            type2: new THREE.MeshStandardMaterial({ 
                color: 0x6666ff, side: THREE.DoubleSide, 
                transparent: true, opacity: 0.85, roughness: 0.5 
            }),
            type3: new THREE.MeshStandardMaterial({ 
                color: 0xff6666, side: THREE.DoubleSide, 
                transparent: true, opacity: 0.85, roughness: 0.5 
            }),
            edge: new THREE.LineBasicMaterial({ color: 0x000000 }),
            outerOcta: new THREE.LineBasicMaterial({ color: 0xffaa00, linewidth: 2 })
        };
        
        // Create mesh groups by type
        const meshGroups = { type1: [], type2: [], type3: [] };
        const edgeLines = [];
        
        triangles.forEach(tri => {
            const [i, j, k] = tri.verts;
            const v1 = vec3(verticesUnit[i]);
            const v2 = vec3(verticesUnit[j]);
            const v3 = vec3(verticesUnit[k]);
            
            // Create face
            const geom = new THREE.BufferGeometry();
            geom.setFromPoints([v1, v2, v3]);
            geom.computeVertexNormals();
            
            const mat = materials[`type${tri.type}`] || materials.type1;
            const mesh = new THREE.Mesh(geom, mat);
            mainGroup.add(mesh);
            meshGroups[`type${tri.type}`].push(mesh);
            
            // Create edges
            const edgeGeom = new THREE.BufferGeometry().setFromPoints([v1, v2, v3, v1]);
            const edge = new THREE.Line(edgeGeom, materials.edge);
            mainGroup.add(edge);
            edgeLines.push(edge);
        });
        
        // Outer octahedron
        const outerOctaLines = [];
        EDGES.forEach(([i, j]) => {
            const pts = [vec3(toUnit(OUTER[i])), vec3(toUnit(OUTER[j]))];
            const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), materials.outerOcta);
            line.visible = false;
            mainGroup.add(line);
            outerOctaLines.push(line);
        });
        
        // Controls
        document.getElementById('showEdges').addEventListener('change', (e) => {
            edgeLines.forEach(line => line.visible = e.target.checked);
        });
        
        document.getElementById('showOuterOcta').addEventListener('change', (e) => {
            outerOctaLines.forEach(line => line.visible = e.target.checked);
        });
        
        document.getElementById('showType1').addEventListener('change', (e) => {
            meshGroups.type1.forEach(m => m.visible = e.target.checked);
        });
        
        document.getElementById('showType2').addEventListener('change', (e) => {
            meshGroups.type2.forEach(m => m.visible = e.target.checked);
        });
        
        document.getElementById('showType3').addEventListener('change', (e) => {
            meshGroups.type3.forEach(m => m.visible = e.target.checked);
        });
        
        // Mouse controls
        let drag = false, pm = {x:0, y:0};
        container.addEventListener('mousedown', e => { drag = true; pm = {x:e.clientX, y:e.clientY}; });
        container.addEventListener('mousemove', e => {
            if (drag) {
                mainGroup.rotation.y += (e.clientX - pm.x) * 0.01;
                mainGroup.rotation.x += (e.clientY - pm.y) * 0.01;
                pm = {x:e.clientX, y:e.clientY};
            }
        });
        container.addEventListener('mouseup', () => drag = false);
        container.addEventListener('mouseleave', () => drag = false);
        container.addEventListener('wheel', e => { 
            e.preventDefault(); 
            camera.position.z *= (1 + e.deltaY*0.001);
            camera.position.z = Math.max(1.5, Math.min(10, camera.position.z));
        }, {passive:false});
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Animation
        function animate() {
            requestAnimationFrame(animate);
            if (document.getElementById('autoRotate').checked && !drag) {
                mainGroup.rotation.y += 0.005;
            }
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>
