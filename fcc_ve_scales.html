<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FCC - VE at Two Scales</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: system-ui, sans-serif; background: #0a0a12; color: #eee; overflow: hidden; }
        #controls {
            position: fixed; top: 15px; left: 15px;
            background: rgba(18, 18, 26, 0.95); padding: 15px; border-radius: 8px;
            z-index: 100; width: 260px;
        }
        h1 { font-size: 1rem; color: #7af; margin-bottom: 12px; }
        h2 { font-size: 0.85rem; color: #aaa; margin: 12px 0 6px 0; border-top: 1px solid #333; padding-top: 10px; }
        .control-row { margin: 8px 0; font-size: 0.8rem; }
        .control-row label { display: flex; align-items: center; gap: 8px; }
        input[type="checkbox"] { margin: 0; }
        .info { font-size: 0.7rem; color: #888; margin-top: 12px; line-height: 1.5; }
        .color-dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; margin-right: 6px; }
        #canvas-container { width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <div id="controls">
        <h1>VE at Two Scales</h1>
        
        <div class="control-row">
            <label><input type="checkbox" id="autoRotate" checked> Auto Rotate</label>
        </div>
        
        <h2>Large Scale VE</h2>
        <div class="control-row">
            <label><input type="checkbox" id="showLargeSpheres" checked> <span class="color-dot" style="background:#ff4444"></span>Large red spheres</label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="showLargeEdges" checked> Large VE edges</label>
        </div>
        
        <h2>Small Scale VE</h2>
        <div class="control-row">
            <label><input type="checkbox" id="showSmallSpheres" checked> <span class="color-dot" style="background:#ffffff"></span>Small white spheres</label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="showSmallEdges"> Small VE edges</label>
        </div>
        
        <h2>Unit Cells</h2>
        <div class="control-row">
            <label><input type="checkbox" id="showLargeCells"> Large cells (red)</label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="showSmallCells"> Small cells (white)</label>
        </div>
        
        <div class="info">
            <strong>Red:</strong> VE at original scale<br>
            <strong>White:</strong> VE at half scale<br><br>
            The same pattern nests within itself infinitely.
        </div>
    </div>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Large scale: VE neighbors at distance sqrt(2)*2 from origin
        // Small scale: VE neighbors at distance sqrt(2) from origin
        
        const LARGE_NN = Math.sqrt(2) * 2;
        const SMALL_NN = Math.sqrt(2);
        
        const LARGE_RADIUS = LARGE_NN / 2;
        const SMALL_RADIUS = SMALL_NN / 2;
        
        // VE neighbor directions (permutations of ±1, ±1, 0)
        const veDirections = [
            [1, 1, 0], [1, -1, 0], [-1, 1, 0], [-1, -1, 0],
            [1, 0, 1], [1, 0, -1], [-1, 0, 1], [-1, 0, -1],
            [0, 1, 1], [0, 1, -1], [0, -1, 1], [0, -1, -1]
        ];
        
        // Large VE vertices (centered on origin)
        const largeVE = veDirections.map(d => [d[0] * 2, d[1] * 2, d[2] * 2]);
        
        // Small VE vertices (centered on origin)
        const smallVE = veDirections.map(d => [d[0], d[1], d[2]]);
        
        // Find edges (pairs at distance = NN)
        function findVEEdges(vertices, nnDist) {
            const edges = [];
            for (let i = 0; i < vertices.length; i++) {
                for (let j = i + 1; j < vertices.length; j++) {
                    const d = Math.sqrt(
                        (vertices[i][0] - vertices[j][0])**2 +
                        (vertices[i][1] - vertices[j][1])**2 +
                        (vertices[i][2] - vertices[j][2])**2
                    );
                    if (Math.abs(d - nnDist) < 0.01) {
                        edges.push([i, j]);
                    }
                }
            }
            return edges;
        }
        
        const largeEdges = findVEEdges(largeVE, LARGE_NN);
        const smallEdges = findVEEdges(smallVE, SMALL_NN);
        
        // Three.js setup
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a12);
        
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(6, 5, 8);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);
        
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const light1 = new THREE.DirectionalLight(0xffffff, 0.8);
        light1.position.set(10, 10, 10);
        scene.add(light1);
        const light2 = new THREE.DirectionalLight(0xffffff, 0.3);
        light2.position.set(-5, -5, -5);
        scene.add(light2);
        
        const mainGroup = new THREE.Group();
        scene.add(mainGroup);
        
        function drawCube(corner, size, material) {
            const [cx, cy, cz] = corner;
            const s = size;
            const edges = [
                [[cx,cy,cz], [cx+s,cy,cz]], [[cx+s,cy,cz], [cx+s,cy+s,cz]], 
                [[cx+s,cy+s,cz], [cx,cy+s,cz]], [[cx,cy+s,cz], [cx,cy,cz]],
                [[cx,cy,cz+s], [cx+s,cy,cz+s]], [[cx+s,cy,cz+s], [cx+s,cy+s,cz+s]], 
                [[cx+s,cy+s,cz+s], [cx,cy+s,cz+s]], [[cx,cy+s,cz+s], [cx,cy,cz+s]],
                [[cx,cy,cz], [cx,cy,cz+s]], [[cx+s,cy,cz], [cx+s,cy,cz+s]], 
                [[cx+s,cy+s,cz], [cx+s,cy+s,cz+s]], [[cx,cy+s,cz], [cx,cy+s,cz+s]]
            ];
            
            const lines = [];
            for (const [p1, p2] of edges) {
                const geom = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(...p1), new THREE.Vector3(...p2)
                ]);
                lines.push(new THREE.Line(geom, material));
            }
            return lines;
        }
        
        function rebuild() {
            while (mainGroup.children.length) mainGroup.remove(mainGroup.children[0]);
            
            const showLargeSpheres = document.getElementById('showLargeSpheres').checked;
            const showSmallSpheres = document.getElementById('showSmallSpheres').checked;
            const showLargeEdges = document.getElementById('showLargeEdges').checked;
            const showSmallEdges = document.getElementById('showSmallEdges').checked;
            const showLargeCells = document.getElementById('showLargeCells').checked;
            const showSmallCells = document.getElementById('showSmallCells').checked;
            
            // Large VE spheres (red)
            if (showLargeSpheres) {
                const geom = new THREE.SphereGeometry(LARGE_RADIUS, 32, 32);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: 0xff4444, 
                    roughness: 0.3,
                    transparent: true,
                    opacity: 0.7
                });
                
                for (const v of largeVE) {
                    const sphere = new THREE.Mesh(geom, mat);
                    sphere.position.set(...v);
                    mainGroup.add(sphere);
                }
            }
            
            // Large VE edges
            if (showLargeEdges) {
                const mat = new THREE.LineBasicMaterial({ color: 0xff4444 });
                for (const [i, j] of largeEdges) {
                    const geom = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(...largeVE[i]),
                        new THREE.Vector3(...largeVE[j])
                    ]);
                    mainGroup.add(new THREE.Line(geom, mat));
                }
            }
            
            // Small VE spheres (white)
            if (showSmallSpheres) {
                const geom = new THREE.SphereGeometry(SMALL_RADIUS, 32, 32);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff, 
                    roughness: 0.3
                });
                
                for (const v of smallVE) {
                    const sphere = new THREE.Mesh(geom, mat);
                    sphere.position.set(...v);
                    mainGroup.add(sphere);
                }
            }
            
            // Small VE edges
            if (showSmallEdges) {
                const mat = new THREE.LineBasicMaterial({ color: 0xffffff });
                for (const [i, j] of smallEdges) {
                    const geom = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(...smallVE[i]),
                        new THREE.Vector3(...smallVE[j])
                    ]);
                    mainGroup.add(new THREE.Line(geom, mat));
                }
            }
            
            // Large unit cells
            if (showLargeCells) {
                const mat = new THREE.LineBasicMaterial({ color: 0xff4444, transparent: true, opacity: 0.5 });
                const s = 4; // large cell size
                const corners = [
                    [0,0,0], [-s,0,0], [0,-s,0], [0,0,-s],
                    [-s,-s,0], [-s,0,-s], [0,-s,-s], [-s,-s,-s]
                ];
                for (const c of corners) {
                    drawCube(c, s, mat).forEach(l => mainGroup.add(l));
                }
            }
            
            // Small unit cells
            if (showSmallCells) {
                const mat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 });
                const s = 2; // small cell size
                const corners = [
                    [0,0,0], [-s,0,0], [0,-s,0], [0,0,-s],
                    [-s,-s,0], [-s,0,-s], [0,-s,-s], [-s,-s,-s]
                ];
                for (const c of corners) {
                    drawCube(c, s, mat).forEach(l => mainGroup.add(l));
                }
            }
        }
        
        rebuild();
        
        document.querySelectorAll('input').forEach(el => {
            el.addEventListener('change', rebuild);
        });
        
        // Mouse controls
        let isDragging = false;
        let prevMouse = { x: 0, y: 0 };
        
        container.addEventListener('mousedown', e => {
            isDragging = true;
            prevMouse = { x: e.clientX, y: e.clientY };
        });
        
        container.addEventListener('mousemove', e => {
            if (isDragging) {
                mainGroup.rotation.y += (e.clientX - prevMouse.x) * 0.01;
                mainGroup.rotation.x += (e.clientY - prevMouse.y) * 0.01;
                prevMouse = { x: e.clientX, y: e.clientY };
            }
        });
        
        container.addEventListener('mouseup', () => isDragging = false);
        container.addEventListener('mouseleave', () => isDragging = false);
        
        container.addEventListener('wheel', e => {
            e.preventDefault();
            camera.position.multiplyScalar(1 + e.deltaY * 0.001);
        }, { passive: false });
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        function animate() {
            requestAnimationFrame(animate);
            if (document.getElementById('autoRotate').checked && !isDragging) {
                mainGroup.rotation.y += 0.003;
            }
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>
