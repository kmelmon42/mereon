<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>144-Face Core - Flat (Coplanar) with FCC Lattice</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: system-ui, sans-serif; background: #0a0a12; color: #eee; overflow: hidden; }
        #controls {
            position: fixed; top: 15px; left: 15px;
            background: rgba(18, 18, 26, 0.95); padding: 15px; border-radius: 8px;
            z-index: 100; width: 280px;
        }
        h1 { font-size: 1rem; color: #7af; margin-bottom: 12px; }
        h2 { font-size: 0.85rem; color: #aaa; margin: 12px 0 6px 0; border-top: 1px solid #333; padding-top: 10px; }
        .control-row { margin: 6px 0; font-size: 0.8rem; }
        .control-row label { display: flex; align-items: center; gap: 8px; cursor: pointer; }
        input[type="checkbox"] { margin: 0; }
        .info { font-size: 0.7rem; color: #888; margin-top: 12px; line-height: 1.5; }
        #canvas-container { width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <div id="controls">
        <h1>144 Core - Flat (Coplanar)</h1>
        
        <div class="control-row">
            <label><input type="checkbox" id="autoRotate"> Auto Rotate</label>
        </div>
        
        <h2>Display</h2>
        <div class="control-row">
            <label><input type="checkbox" id="showFaces" checked> Show Faces</label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="showEdges" checked> Show Edges</label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="showVertices"> Show 144 Vertices</label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="showOctahedron"> Base Octahedron</label>
        </div>
        
        <h2>FCC Lattice</h2>
        <div class="control-row">
            <label><input type="checkbox" id="showFCCLattice"> Show FCC Points</label>
        </div>
        
        <div class="info">
            Flat version: all triangles coplanar with octahedron faces.<br><br>
            All 74 vertices on FCC lattice.<br><br>
            Gray = FCC lattice points<br>
            Yellow = points used by 144
        </div>
    </div>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Octahedron vertices (unit)
        const octaVerts = [
            [1, 0, 0], [-1, 0, 0],
            [0, 1, 0], [0, -1, 0],
            [0, 0, 1], [0, 0, -1]
        ];
        
        const octaFaces = [
            [0, 2, 4], [0, 4, 3], [0, 3, 5], [0, 5, 2],
            [1, 4, 2], [1, 3, 4], [1, 5, 3], [1, 2, 5],
        ];
        
        function vec3(arr) { return new THREE.Vector3(arr[0], arr[1], arr[2]); }
        function avg(...verts) {
            const n = verts.length;
            return [
                verts.reduce((s, v) => s + v[0], 0) / n,
                verts.reduce((s, v) => s + v[1], 0) / n,
                verts.reduce((s, v) => s + v[2], 0) / n
            ];
        }
        
        function build144Flat() {
            const vertices = [];
            const triangles = [];
            const vertexMap = {};
            
            function addVertex(v) {
                const key = v.map(x => Math.round(x * 10000)).join(',');
                if (!(key in vertexMap)) {
                    vertexMap[key] = vertices.length;
                    vertices.push([...v]);
                }
                return vertexMap[key];
            }
            
            for (const face of octaFaces) {
                const A = octaVerts[face[0]];
                const B = octaVerts[face[1]];
                const C = octaVerts[face[2]];
                
                // Face center - NO protrusion, stays flat
                const O = avg(A, B, C);
                
                // Edge midpoints
                const M_AB = avg(A, B);
                const M_BC = avg(B, C);
                const M_CA = avg(C, A);
                
                // 6 level-1 triangles
                const level1 = [
                    [A, M_AB, O], [M_AB, B, O], [B, M_BC, O],
                    [M_BC, C, O], [C, M_CA, O], [M_CA, A, O]
                ];
                
                for (const [P, Q, R] of level1) {
                    // Centroid - NO protrusion, stays flat
                    const cent = avg(P, Q, R);
                    
                    // 3 small triangles
                    const pIdx = addVertex(P);
                    const qIdx = addVertex(Q);
                    const rIdx = addVertex(R);
                    const cIdx = addVertex(cent);
                    
                    triangles.push([pIdx, qIdx, cIdx]);
                    triangles.push([qIdx, rIdx, cIdx]);
                    triangles.push([rIdx, pIdx, cIdx]);
                }
            }
            
            return { vertices, triangles };
        }
        
        // Three.js setup
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a12);
        
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 4);
        camera.lookAt(0, 0, 0);
        camera.up.set(0, 1, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);
        
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        const light1 = new THREE.DirectionalLight(0xffffff, 0.8);
        light1.position.set(5, 5, 5);
        scene.add(light1);
        const light2 = new THREE.DirectionalLight(0xffffff, 0.3);
        light2.position.set(-5, -5, 5);
        scene.add(light2);
        
        const mainGroup = new THREE.Group();
        mainGroup.rotation.z = Math.PI / 4;
        scene.add(mainGroup);
        
        // Pre-compute everything once
        const { vertices, triangles } = build144Flat();
        
        // Generate FCC lattice points at scale 18 (minimum for flat version)
        const fccPoints = [];
        const SCALE = 18;
        for (let sx = -20; sx <= 20; sx++) {
            for (let sy = -20; sy <= 20; sy++) {
                for (let sz = -20; sz <= 20; sz++) {
                    if ((sx + sy + sz) % 2 === 0) {
                        const x = sx / SCALE, y = sy / SCALE, z = sz / SCALE;
                        const dist = Math.sqrt(x*x + y*y + z*z);
                        if (dist <= 1.1) {
                            fccPoints.push([x, y, z]);
                        }
                    }
                }
            }
        }
        console.log("FCC points:", fccPoints.length);
        
        // Create set of vertices used by 144 (at scale 18)
        const usedSet = new Set(vertices.map(v => 
            v.map(c => Math.round(c * SCALE)).join(',')
        ));
        
        console.log("144 vertices:", vertices.length);
        console.log("Used FCC points:", [...usedSet].length);
        
        // Pre-create geometries and materials
        const smallSphereGeom = new THREE.SphereGeometry(0.008, 4, 4);
        const grayMat = new THREE.MeshStandardMaterial({ color: 0x666666, transparent: true, opacity: 0.3 });
        const usedMat = new THREE.MeshStandardMaterial({ color: 0xffff00 });
        const vertexSphereGeom = new THREE.SphereGeometry(0.02, 8, 8);
        const vertexMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
        
        function rebuild() {
            while (mainGroup.children.length) mainGroup.remove(mainGroup.children[0]);
            
            const showFaces = document.getElementById('showFaces').checked;
            const showEdges = document.getElementById('showEdges').checked;
            const showVertices = document.getElementById('showVertices').checked;
            const showOctahedron = document.getElementById('showOctahedron').checked;
            const showFCCLattice = document.getElementById('showFCCLattice').checked;
            
            // Draw faces
            if (showFaces) {
                const geom = new THREE.BufferGeometry();
                const positions = [];
                
                for (const tri of triangles) {
                    for (const idx of tri) {
                        positions.push(...vertices[idx]);
                    }
                }
                
                geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geom.computeVertexNormals();
                
                const mat = new THREE.MeshStandardMaterial({
                    color: 0x4488ff,
                    side: THREE.DoubleSide,
                    roughness: 0.6,
                    metalness: 0.1
                });
                mainGroup.add(new THREE.Mesh(geom, mat));
            }
            
            // Draw edges
            if (showEdges) {
                const edgeMat = new THREE.LineBasicMaterial({ color: 0x000000 });
                for (const tri of triangles) {
                    const pts = [
                        vec3(vertices[tri[0]]),
                        vec3(vertices[tri[1]]),
                        vec3(vertices[tri[2]]),
                        vec3(vertices[tri[0]])
                    ];
                    mainGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), edgeMat));
                }
            }
            
            // Draw vertices
            if (showVertices) {
                for (const v of vertices) {
                    const sphere = new THREE.Mesh(vertexSphereGeom, vertexMat);
                    sphere.position.set(...v);
                    mainGroup.add(sphere);
                }
            }
            
            // Draw octahedron
            if (showOctahedron) {
                const octaEdges = [[0,2],[0,3],[0,4],[0,5],[1,2],[1,3],[1,4],[1,5],[2,4],[4,3],[3,5],[5,2]];
                const octaMat = new THREE.LineBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.5 });
                for (const [i,j] of octaEdges) {
                    const pts = [vec3(octaVerts[i]), vec3(octaVerts[j])];
                    mainGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), octaMat));
                }
            }
            
            // Draw FCC lattice points
            if (showFCCLattice) {
                for (const p of fccPoints) {
                    const key = p.map(c => Math.round(c * SCALE)).join(',');
                    const isUsed = usedSet.has(key);
                    const sphere = new THREE.Mesh(smallSphereGeom, isUsed ? usedMat : grayMat);
                    sphere.position.set(...p);
                    mainGroup.add(sphere);
                }
            }
        }
        
        rebuild();
        
        document.querySelectorAll('input').forEach(el => el.addEventListener('change', rebuild));
        
        let isDragging = false, prevMouse = {x:0, y:0};
        container.addEventListener('mousedown', e => { isDragging = true; prevMouse = {x:e.clientX, y:e.clientY}; });
        container.addEventListener('mousemove', e => {
            if (isDragging) {
                mainGroup.rotation.y += (e.clientX - prevMouse.x) * 0.01;
                mainGroup.rotation.x += (e.clientY - prevMouse.y) * 0.01;
                prevMouse = {x:e.clientX, y:e.clientY};
            }
        });
        container.addEventListener('mouseup', () => isDragging = false);
        container.addEventListener('mouseleave', () => isDragging = false);
        container.addEventListener('wheel', e => { e.preventDefault(); camera.position.multiplyScalar(1 + e.deltaY * 0.001); }, {passive:false});
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        
        function animate() {
            requestAnimationFrame(animate);
            if (document.getElementById('autoRotate').checked && !isDragging) mainGroup.rotation.y += 0.005;
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
