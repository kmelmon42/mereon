<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>6 Icosahedra Compound</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: system-ui, sans-serif;
            background: #000;
            color: #eee;
            overflow: hidden;
        }
        #controls {
            position: fixed;
            top: 15px;
            left: 15px;
            background: rgba(18, 18, 26, 0.9);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            width: 220px;
            max-height: calc(100vh - 30px);
            overflow-y: auto;
        }
        h1 { font-size: 1rem; color: #7af; margin-bottom: 10px; }
        .control-row { margin: 8px 0; font-size: 0.85rem; }
        .control-row label { display: block; margin-bottom: 4px; color: #888; }
        input[type="range"] { width: 100%; }
        input[type="checkbox"] { margin-right: 8px; }
        .value { color: #7af; font-weight: bold; }
        #canvas-container { width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <div id="controls">
        <h1>6 Icosahedra</h1>
        <div class="control-row">
            <label><input type="checkbox" id="autoRotate" checked> Auto Rotate View</label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="showEdges" checked> Show Edges</label>
        </div>
        <div class="control-row" style="border-top: 1px solid #333; padding-top: 8px; margin-top: 8px;">
            <label style="color: #ff4444;"><input type="checkbox" id="show1" checked> Icosa 1</label>
        </div>
        <div class="control-row">
            <label style="color: #44ff44;"><input type="checkbox" id="show2" checked> Icosa 2</label>
        </div>
        <div class="control-row">
            <label style="color: #4444ff;"><input type="checkbox" id="show3" checked> Icosa 3</label>
        </div>
        <div class="control-row">
            <label style="color: #ffff44;"><input type="checkbox" id="show4" checked> Icosa 4</label>
        </div>
        <div class="control-row">
            <label style="color: #ff44ff;"><input type="checkbox" id="show5" checked> Icosa 5</label>
        </div>
        <div class="control-row">
            <label style="color: #44ffff;"><input type="checkbox" id="show6" checked> Icosa 6</label>
        </div>
    </div>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const PHI = (1 + Math.sqrt(5)) / 2;
        
        // 5 bisector axes - perpendicular to plane containing origin, top vertex, and base midpoint
        // Rotating around these keeps points in the bisecting plane
        const BISECTOR_AXES = [
            new THREE.Vector3(-0.9511, 0, -0.3090),   // Triangle 0
            new THREE.Vector3(0.0000, 0, -1.0000),    // Triangle 1
            new THREE.Vector3(0.9511, 0, -0.3090),    // Triangle 2
            new THREE.Vector3(0.5878, 0, 0.8090),     // Triangle 3
            new THREE.Vector3(-0.5878, 0, 0.8090),    // Triangle 4
        ];
        
        // All 6 icosahedra start in identical orientation
        const AXES = [
            new THREE.Vector3(0, 1, 0),
            new THREE.Vector3(0, 1, 0),
            new THREE.Vector3(0, 1, 0),
            new THREE.Vector3(0, 1, 0),
            new THREE.Vector3(0, 1, 0),
            new THREE.Vector3(0, 1, 0),
        ];
        
        let icosa6BisectorIdx = 0;
        let allRotation = Math.atan(0.5) * 180 / Math.PI;  // atan(1/2) ≈ 26.565°
        
        // Each icosahedron 2-6 gets a different bisector axis
        const ICOSA_BISECTOR_IDX = [
            -1,  // icosa 1 (index 0) - no rotation
            0,   // icosa 2 (index 1) - bisector 0
            1,   // icosa 3 (index 2) - bisector 1
            2,   // icosa 4 (index 3) - bisector 2
            3,   // icosa 5 (index 4) - bisector 3
            4,   // icosa 6 (index 5) - bisector 4
        ];
        
        const COLORS = [
            0xff4444,  // red
            0x44ff44,  // green
            0x4444ff,  // blue
            0xffff44,  // yellow
            0xff44ff,  // magenta
            0x44ffff,  // cyan
        ];

        // Three.js setup
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 5);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);
        
        // Lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        const light1 = new THREE.DirectionalLight(0xffffff, 0.8);
        light1.position.set(5, 5, 5);
        scene.add(light1);
        const light2 = new THREE.DirectionalLight(0xffffff, 0.3);
        light2.position.set(-5, -5, 5);
        scene.add(light2);

        const mainGroup = new THREE.Group();
        // Rotate so +Y axis points toward camera (+Z direction)
        // This puts the red icosahedron's top vertex facing the viewer
        mainGroup.rotation.x = -Math.PI / 2;
        scene.add(mainGroup);

        // Create icosahedron
        function createIcosahedron(color, showEdges, icosaIndex) {
            const group = new THREE.Group();
            
            const geometry = new THREE.IcosahedronGeometry(1, 0);
            
            const material = new THREE.MeshStandardMaterial({
                color: color,
                side: THREE.DoubleSide,
                roughness: 0.6,
                metalness: 0.1,
                polygonOffset: true,
                polygonOffsetFactor: icosaIndex * 0.1,
                polygonOffsetUnits: icosaIndex * 0.1,
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            group.add(mesh);
            
            if (showEdges) {
                const edgesGeometry = new THREE.EdgesGeometry(geometry);
                const edgesMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
                const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
                group.add(edges);
            }
            
            return group;
        }

        // Build compound
        let icosahedra = [];
        let showEdges = true;
        let spinAngle = 0;  // Keep but not controllable
        
        function buildCompound() {
            // Clear existing
            icosahedra.forEach(ico => mainGroup.remove(ico));
            icosahedra = [];
            
            for (let i = 0; i < 6; i++) {
                const ico = createIcosahedron(COLORS[i], showEdges, i);
                
                // All icosahedra start with vertex pointing up (Y axis)
                // Three.js IcosahedronGeometry has highest vertex at (1, PHI, 0)
                // We need to rotate to put a vertex on the Y axis
                
                // First, rotate to align a vertex with Y axis
                // Vertex (1, PHI, 0) needs to go to (0, Y, 0)
                // Rotate around Z axis by angle to bring X component to 0
                const alignAngle = Math.atan2(1, PHI); // angle of (1, PHI) from Y axis in XY plane
                const alignQuat = new THREE.Quaternion();
                alignQuat.setFromAxisAngle(new THREE.Vector3(0, 0, 1), alignAngle);
                
                // Icosahedra 2-6 (indices 1-5) get rotated 180° about Y
                const flipQuat = new THREE.Quaternion();
                if (i > 0) {
                    flipQuat.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);
                }
                
                // Icosahedra 2-6 get rotation around their assigned bisector axis
                const bisectorQuat = new THREE.Quaternion();
                if (i > 0) {
                    const bisectorIdx = ICOSA_BISECTOR_IDX[i];
                    const bisectorAxis = BISECTOR_AXES[bisectorIdx];
                    bisectorQuat.setFromAxisAngle(bisectorAxis, allRotation * Math.PI / 180);
                }
                
                // Then apply spin around Y axis
                const spinQuat = new THREE.Quaternion();
                spinQuat.setFromAxisAngle(new THREE.Vector3(0, 1, 0), spinAngle * Math.PI / 180);
                
                ico.quaternion.copy(spinQuat).multiply(bisectorQuat).multiply(flipQuat).multiply(alignQuat);
                
                icosahedra.push(ico);
                mainGroup.add(ico);
            }
            
            updateVisibility();
        }
        
        function updateVisibility() {
            for (let i = 0; i < 6; i++) {
                const checkbox = document.getElementById(`show${i + 1}`);
                if (icosahedra[i]) {
                    icosahedra[i].visible = checkbox.checked;
                }
            }
        }

        buildCompound();

        // Controls
        const autoRotateCheck = document.getElementById('autoRotate');
        const showEdgesCheck = document.getElementById('showEdges');
        
        showEdgesCheck.addEventListener('change', (e) => {
            showEdges = e.target.checked;
            buildCompound();
        });
        
        for (let i = 1; i <= 6; i++) {
            document.getElementById(`show${i}`).addEventListener('change', updateVisibility);
        }

        // Mouse controls
        let isDragging = false;
        let prevMouse = { x: 0, y: 0 };

        container.addEventListener('mousedown', (e) => {
            isDragging = true;
            prevMouse = { x: e.clientX, y: e.clientY };
        });

        container.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - prevMouse.x;
                const dy = e.clientY - prevMouse.y;
                mainGroup.rotation.z += dx * 0.01;
                mainGroup.rotation.x += dy * 0.01;
                prevMouse = { x: e.clientX, y: e.clientY };
            }
        });

        container.addEventListener('mouseup', () => isDragging = false);
        container.addEventListener('mouseleave', () => isDragging = false);

        // Zoom
        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomSpeed = 0.001;
            const scaleFactor = 1 + e.deltaY * zoomSpeed;
            mainGroup.scale.multiplyScalar(1 / scaleFactor);
            const s = mainGroup.scale.x;
            if (s < 0.1) mainGroup.scale.setScalar(0.1);
            if (s > 10) mainGroup.scale.setScalar(10);
        }, { passive: false });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Render loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (autoRotateCheck.checked && !isDragging) {
                mainGroup.rotation.z += 0.005;
            }
            
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
