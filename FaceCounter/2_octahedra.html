<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2 Octahedra</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: system-ui, sans-serif;
            background: #000;
            color: #eee;
            overflow: hidden;
        }
        #controls {
            position: fixed;
            top: 15px;
            left: 15px;
            background: rgba(18, 18, 26, 0.9);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            width: 240px;
        }
        h1 { font-size: 1rem; color: #7af; margin-bottom: 10px; }
        .control-row { margin: 8px 0; font-size: 0.85rem; }
        .control-row label { display: block; margin-bottom: 4px; color: #888; }
        input[type="range"] { width: 100%; }
        input[type="checkbox"] { margin-right: 8px; }
        .value { color: #7af; font-weight: bold; }
        #canvas-container { width: 100vw; height: 100vh; }
        #info { 
            position: fixed; 
            bottom: 15px; 
            left: 15px; 
            background: rgba(18, 18, 26, 0.9);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.85rem;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h1>2 Octahedra</h1>
        <div class="control-row">
            <label>Rotation Angle: <span id="angleValue" class="value">0°</span></label>
            <input type="range" id="angleSlider" min="0" max="180" value="0" step="1">
        </div>
        <div class="control-row">
            <label>Rotation Axis:</label>
            <select id="axisSelect">
                <option value="y">Y axis (0,1,0)</option>
                <option value="x">X axis (1,0,0)</option>
                <option value="z">Z axis (0,0,1)</option>
                <option value="111">Diagonal (1,1,1)</option>
            </select>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="autoRotate" checked> Auto Rotate View</label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="showEdges" checked> Show Edges</label>
        </div>
        <div class="control-row">
            <label style="color: #ff4444;"><input type="checkbox" id="show1" checked> Octahedron 1</label>
        </div>
        <div class="control-row">
            <label style="color: #4444ff;"><input type="checkbox" id="show2" checked> Octahedron 2</label>
        </div>
    </div>
    <div id="info">
        Simple face count: <span id="faceCount">16</span> (8 + 8)
    </div>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const COLORS = [0xff4444, 0x4444ff];
        
        const AXES = {
            'x': new THREE.Vector3(1, 0, 0),
            'y': new THREE.Vector3(0, 1, 0),
            'z': new THREE.Vector3(0, 0, 1),
            '111': new THREE.Vector3(1, 1, 1).normalize()
        };

        // Three.js setup
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 5);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);
        
        // Lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        const light1 = new THREE.DirectionalLight(0xffffff, 0.8);
        light1.position.set(5, 5, 5);
        scene.add(light1);
        const light2 = new THREE.DirectionalLight(0xffffff, 0.3);
        light2.position.set(-5, -5, 5);
        scene.add(light2);

        const mainGroup = new THREE.Group();
        scene.add(mainGroup);

        function createOctahedron(color, showEdges, index) {
            const group = new THREE.Group();
            
            const geometry = new THREE.OctahedronGeometry(1, 0);
            
            const material = new THREE.MeshStandardMaterial({
                color: color,
                side: THREE.DoubleSide,
                roughness: 0.6,
                metalness: 0.1,
                transparent: true,
                opacity: 0.7,
                polygonOffset: true,
                polygonOffsetFactor: index * 0.1,
                polygonOffsetUnits: index * 0.1,
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            group.add(mesh);
            
            if (showEdges) {
                const edgesGeometry = new THREE.EdgesGeometry(geometry);
                const edgesMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
                const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
                group.add(edges);
            }
            
            return group;
        }

        let octahedra = [];
        let showEdges = true;
        let rotationAngle = 0;
        let rotationAxis = 'y';
        
        function buildCompound() {
            octahedra.forEach(oct => mainGroup.remove(oct));
            octahedra = [];
            
            // Octahedron 1 - fixed
            const oct1 = createOctahedron(COLORS[0], showEdges, 0);
            octahedra.push(oct1);
            mainGroup.add(oct1);
            
            // Octahedron 2 - rotated
            const oct2 = createOctahedron(COLORS[1], showEdges, 1);
            const axis = AXES[rotationAxis];
            oct2.quaternion.setFromAxisAngle(axis, rotationAngle * Math.PI / 180);
            octahedra.push(oct2);
            mainGroup.add(oct2);
            
            updateVisibility();
        }
        
        function updateVisibility() {
            if (octahedra[0]) octahedra[0].visible = document.getElementById('show1').checked;
            if (octahedra[1]) octahedra[1].visible = document.getElementById('show2').checked;
        }

        buildCompound();

        // Controls
        const angleSlider = document.getElementById('angleSlider');
        const angleValue = document.getElementById('angleValue');
        const axisSelect = document.getElementById('axisSelect');
        const autoRotateCheck = document.getElementById('autoRotate');
        const showEdgesCheck = document.getElementById('showEdges');
        
        angleSlider.addEventListener('input', (e) => {
            rotationAngle = parseFloat(e.target.value);
            angleValue.textContent = rotationAngle + '°';
            buildCompound();
        });
        
        axisSelect.addEventListener('change', (e) => {
            rotationAxis = e.target.value;
            buildCompound();
        });
        
        showEdgesCheck.addEventListener('change', (e) => {
            showEdges = e.target.checked;
            buildCompound();
        });
        
        document.getElementById('show1').addEventListener('change', updateVisibility);
        document.getElementById('show2').addEventListener('change', updateVisibility);

        // Mouse controls
        let isDragging = false;
        let prevMouse = { x: 0, y: 0 };

        container.addEventListener('mousedown', (e) => {
            isDragging = true;
            prevMouse = { x: e.clientX, y: e.clientY };
        });

        container.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - prevMouse.x;
                const dy = e.clientY - prevMouse.y;
                mainGroup.rotation.y += dx * 0.01;
                mainGroup.rotation.x += dy * 0.01;
                prevMouse = { x: e.clientX, y: e.clientY };
            }
        });

        container.addEventListener('mouseup', () => isDragging = false);
        container.addEventListener('mouseleave', () => isDragging = false);

        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomSpeed = 0.001;
            const scaleFactor = 1 + e.deltaY * zoomSpeed;
            mainGroup.scale.multiplyScalar(1 / scaleFactor);
            const s = mainGroup.scale.x;
            if (s < 0.1) mainGroup.scale.setScalar(0.1);
            if (s > 10) mainGroup.scale.setScalar(10);
        }, { passive: false });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            
            if (autoRotateCheck.checked && !isDragging) {
                mainGroup.rotation.y += 0.005;
            }
            
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
