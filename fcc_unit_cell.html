<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FCC Unit Cell</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: system-ui, sans-serif; background: #0a0a12; color: #eee; overflow: hidden; }
        #controls {
            position: fixed; top: 15px; left: 15px;
            background: rgba(18, 18, 26, 0.95); padding: 15px; border-radius: 8px;
            z-index: 100; width: 260px;
        }
        h1 { font-size: 1rem; color: #7af; margin-bottom: 12px; }
        .control-row { margin: 8px 0; font-size: 0.8rem; }
        .control-row label { display: flex; align-items: center; gap: 8px; }
        input[type="checkbox"] { margin: 0; }
        .info { font-size: 0.75rem; color: #888; margin-top: 12px; line-height: 1.6; }
        .color-dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; margin-right: 6px; }
        #canvas-container { width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <div id="controls">
        <h1>FCC Unit Cell</h1>
        
        <div class="control-row">
            <label><input type="checkbox" id="autoRotate" checked> Auto Rotate</label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="showCube" checked> Show Cube Edges</label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="showLabels" checked> Show Labels</label>
        </div>
        
        <div class="info">
            <strong>FCC Unit Cell Points:</strong><br><br>
            <span class="color-dot" style="background:#ff4444"></span><strong>8 Corners</strong> (0,0,0) etc.<br>
            <span style="margin-left: 18px; color: #666;">(shared with 8 cells → ⅛ each)</span><br><br>
            <span class="color-dot" style="background:#44ff44"></span><strong>6 Face Centers</strong><br>
            <span style="margin-left: 18px;">(½,½,0), (½,0,½), (0,½,½)</span><br>
            <span style="margin-left: 18px;">(½,½,1), (½,1,½), (1,½,½)</span><br>
            <span style="margin-left: 18px; color: #666;">(shared with 2 cells → ½ each)</span><br><br>
            <strong>Points per cell:</strong> 8×⅛ + 6×½ = <strong>4</strong>
        </div>
    </div>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Unit cell corners (8)
        const corners = [
            [0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1],
            [1, 1, 0], [1, 0, 1], [0, 1, 1], [1, 1, 1]
        ];
        
        // Face centers (6)
        const faceCenters = [
            [0.5, 0.5, 0],   // bottom (xy plane, z=0)
            [0.5, 0.5, 1],   // top (xy plane, z=1)
            [0.5, 0, 0.5],   // front (xz plane, y=0)
            [0.5, 1, 0.5],   // back (xz plane, y=1)
            [0, 0.5, 0.5],   // left (yz plane, x=0)
            [1, 0.5, 0.5]    // right (yz plane, x=1)
        ];
        
        // Cube edges
        const cubeEdges = [
            // Bottom face
            [[0,0,0], [1,0,0]], [[1,0,0], [1,1,0]], [[1,1,0], [0,1,0]], [[0,1,0], [0,0,0]],
            // Top face
            [[0,0,1], [1,0,1]], [[1,0,1], [1,1,1]], [[1,1,1], [0,1,1]], [[0,1,1], [0,0,1]],
            // Vertical edges
            [[0,0,0], [0,0,1]], [[1,0,0], [1,0,1]], [[1,1,0], [1,1,1]], [[0,1,0], [0,1,1]]
        ];
        
        // Three.js setup
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a12);
        
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(2.5, 2, 3);
        camera.lookAt(0.5, 0.5, 0.5);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);
        
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const light1 = new THREE.DirectionalLight(0xffffff, 0.8);
        light1.position.set(5, 5, 5);
        scene.add(light1);
        
        const mainGroup = new THREE.Group();
        scene.add(mainGroup);
        
        // For labels
        const labelSprites = [];
        
        function makeTextSprite(text, color) {
            const canvas = document.createElement('canvas');
            const size = 128;
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color;
            ctx.font = 'bold 24px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, size/2, size/2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(0.3, 0.3, 1);
            return sprite;
        }
        
        function rebuild() {
            while (mainGroup.children.length) mainGroup.remove(mainGroup.children[0]);
            labelSprites.length = 0;
            
            // Corner spheres (red)
            const cornerGeom = new THREE.SphereGeometry(0.08, 24, 24);
            const cornerMat = new THREE.MeshStandardMaterial({ color: 0xff4444, roughness: 0.3 });
            
            for (let i = 0; i < corners.length; i++) {
                const sphere = new THREE.Mesh(cornerGeom, cornerMat);
                sphere.position.set(...corners[i]);
                mainGroup.add(sphere);
                
                if (document.getElementById('showLabels').checked) {
                    const label = makeTextSprite(`(${corners[i].join(',')})`, '#ff8888');
                    label.position.set(corners[i][0], corners[i][1] - 0.15, corners[i][2]);
                    mainGroup.add(label);
                    labelSprites.push(label);
                }
            }
            
            // Face center spheres (green)
            const faceGeom = new THREE.SphereGeometry(0.08, 24, 24);
            const faceMat = new THREE.MeshStandardMaterial({ color: 0x44ff44, roughness: 0.3 });
            
            const faceLabels = [
                '(½,½,0)', '(½,½,1)', '(½,0,½)', '(½,1,½)', '(0,½,½)', '(1,½,½)'
            ];
            
            for (let i = 0; i < faceCenters.length; i++) {
                const sphere = new THREE.Mesh(faceGeom, faceMat);
                sphere.position.set(...faceCenters[i]);
                mainGroup.add(sphere);
                
                if (document.getElementById('showLabels').checked) {
                    const label = makeTextSprite(faceLabels[i], '#88ff88');
                    label.position.set(faceCenters[i][0], faceCenters[i][1] - 0.12, faceCenters[i][2]);
                    mainGroup.add(label);
                    labelSprites.push(label);
                }
            }
            
            // Cube edges
            if (document.getElementById('showCube').checked) {
                const edgeMat = new THREE.LineBasicMaterial({ color: 0x888888 });
                
                for (const [p1, p2] of cubeEdges) {
                    const points = [new THREE.Vector3(...p1), new THREE.Vector3(...p2)];
                    const geom = new THREE.BufferGeometry().setFromPoints(points);
                    mainGroup.add(new THREE.Line(geom, edgeMat));
                }
            }
        }
        
        rebuild();
        
        document.querySelectorAll('input').forEach(el => {
            el.addEventListener('change', rebuild);
        });
        
        // Mouse controls
        let isDragging = false;
        let prevMouse = { x: 0, y: 0 };
        
        // Pivot around center of cell
        const pivot = new THREE.Vector3(0.5, 0.5, 0.5);
        
        container.addEventListener('mousedown', e => {
            isDragging = true;
            prevMouse = { x: e.clientX, y: e.clientY };
        });
        
        container.addEventListener('mousemove', e => {
            if (isDragging) {
                const dx = e.clientX - prevMouse.x;
                const dy = e.clientY - prevMouse.y;
                
                // Rotate around center of cell
                mainGroup.position.sub(pivot);
                mainGroup.rotation.y += dx * 0.01;
                mainGroup.rotation.x += dy * 0.01;
                mainGroup.position.add(pivot);
                
                prevMouse = { x: e.clientX, y: e.clientY };
            }
        });
        
        container.addEventListener('mouseup', () => isDragging = false);
        container.addEventListener('mouseleave', () => isDragging = false);
        
        container.addEventListener('wheel', e => {
            e.preventDefault();
            camera.position.sub(pivot);
            camera.position.multiplyScalar(1 + e.deltaY * 0.001);
            camera.position.add(pivot);
        }, { passive: false });
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        function animate() {
            requestAnimationFrame(animate);
            if (document.getElementById('autoRotate').checked && !isDragging) {
                mainGroup.position.sub(pivot);
                mainGroup.rotation.y += 0.005;
                mainGroup.position.add(pivot);
            }
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>
