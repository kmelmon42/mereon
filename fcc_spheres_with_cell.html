<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FCC Spheres with Unit Cell</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: system-ui, sans-serif; background: #0a0a12; color: #eee; overflow: hidden; }
        #controls {
            position: fixed; top: 15px; left: 15px;
            background: rgba(18, 18, 26, 0.95); padding: 15px; border-radius: 8px;
            z-index: 100; width: 280px;
        }
        h1 { font-size: 1rem; color: #7af; margin-bottom: 12px; }
        h2 { font-size: 0.85rem; color: #aaa; margin: 12px 0 6px 0; border-top: 1px solid #333; padding-top: 10px; }
        .control-row { margin: 8px 0; font-size: 0.8rem; }
        .control-row label { display: flex; align-items: center; gap: 8px; }
        input[type="checkbox"] { margin: 0; }
        input[type="range"] { width: 100px; }
        .val { color: #7af; min-width: 30px; }
        .info { font-size: 0.7rem; color: #888; margin-top: 12px; line-height: 1.5; }
        .color-dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; margin-right: 6px; }
        #canvas-container { width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <div id="controls">
        <h1>FCC Spheres + Unit Cell</h1>
        
        <div class="control-row">
            <label><input type="checkbox" id="autoRotate" checked> Auto Rotate</label>
        </div>
        
        <h2>Spheres</h2>
        <div class="control-row">
            <label><input type="checkbox" id="showSpheres" checked> Show Spheres</label>
        </div>
        <div class="control-row">
            <label>Size: <input type="range" id="sphereSize" min="0.3" max="1.0" step="0.05" value="1.0"> <span class="val" id="sphereSizeVal">1.0</span></label>
        </div>
        
        <h2>Unit Cell</h2>
        <div class="control-row">
            <label><input type="checkbox" id="showCell" checked> Show Cubic Cell</label>
        </div>
        
        <h2>Highlight</h2>
        <div class="control-row">
            <label><input type="checkbox" id="highlightCenter" checked> <span class="color-dot" style="background:#ffdd44"></span>Center sphere</label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="highlightVE" checked> <span class="color-dot" style="background:#4488ff"></span>12 VE neighbors</label>
        </div>
        <div class="control-row">
            <label><input type="checkbox" id="showVEEdges"> VE edges</label>
        </div>
        
        <div class="info">
            The yellow sphere is at a shared <strong>corner</strong> of 8 unit cells.<br><br>
            The 12 blue VE neighbors are distributed across these 8 cells - each cell contributes face centers that are VE vertices.<br><br>
            Toggle VE edges to see the cuboctahedron.
        </div>
    </div>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // FCC nearest neighbor distance
        const NN_DIST = Math.sqrt(2);
        const SPHERE_RADIUS = NN_DIST / 2;
        
        // Generate FCC points (using the parity rule, scaled so NN distance = sqrt(2))
        function generateFCC(maxCoord) {
            const points = [];
            for (let i = -maxCoord; i <= maxCoord; i++) {
                for (let j = -maxCoord; j <= maxCoord; j++) {
                    for (let k = -maxCoord; k <= maxCoord; k++) {
                        if ((i + j + k) % 2 === 0) {
                            points.push([i, j, k]);
                        }
                    }
                }
            }
            return points;
        }
        
        // The 12 VE neighbors of origin (nearest neighbors in FCC)
        const veNeighbors = [
            [1, 1, 0], [1, -1, 0], [-1, 1, 0], [-1, -1, 0],
            [1, 0, 1], [1, 0, -1], [-1, 0, 1], [-1, 0, -1],
            [0, 1, 1], [0, 1, -1], [0, -1, 1], [0, -1, -1]
        ];
        
        // VE edges (pairs of neighbors that touch each other)
        const veEdges = [];
        for (let i = 0; i < veNeighbors.length; i++) {
            for (let j = i + 1; j < veNeighbors.length; j++) {
                const d = Math.sqrt(
                    (veNeighbors[i][0] - veNeighbors[j][0])**2 +
                    (veNeighbors[i][1] - veNeighbors[j][1])**2 +
                    (veNeighbors[i][2] - veNeighbors[j][2])**2
                );
                if (Math.abs(d - NN_DIST) < 0.01) {
                    veEdges.push([i, j]);
                }
            }
        }
        
        // Three.js setup
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a12);
        
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 4, 6);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);
        
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const light1 = new THREE.DirectionalLight(0xffffff, 0.8);
        light1.position.set(10, 10, 10);
        scene.add(light1);
        const light2 = new THREE.DirectionalLight(0xffffff, 0.3);
        light2.position.set(-5, -5, -5);
        scene.add(light2);
        
        const mainGroup = new THREE.Group();
        scene.add(mainGroup);
        
        function rebuild() {
            while (mainGroup.children.length) mainGroup.remove(mainGroup.children[0]);
            
            const sphereScale = parseFloat(document.getElementById('sphereSize').value);
            document.getElementById('sphereSizeVal').textContent = sphereScale.toFixed(2);
            
            const showSpheres = document.getElementById('showSpheres').checked;
            const showCell = document.getElementById('showCell').checked;
            const highlightCenter = document.getElementById('highlightCenter').checked;
            const highlightVE = document.getElementById('highlightVE').checked;
            const showVEEdges = document.getElementById('showVEEdges').checked;
            
            // Generate FCC points
            const allPoints = generateFCC(3);
            
            // Filter to region of interest
            const points = allPoints.filter(p => {
                const d = Math.sqrt(p[0]**2 + p[1]**2 + p[2]**2);
                return d <= 2.5 * NN_DIST;
            });
            
            // Draw spheres
            if (showSpheres) {
                const sphereGeom = new THREE.SphereGeometry(SPHERE_RADIUS * sphereScale, 32, 32);
                
                const defaultMat = new THREE.MeshStandardMaterial({
                    color: 0x666666,
                    transparent: true,
                    opacity: 0.4,
                    roughness: 0.3
                });
                const centerMat = new THREE.MeshStandardMaterial({
                    color: 0xffdd44,
                    roughness: 0.3
                });
                const veMat = new THREE.MeshStandardMaterial({
                    color: 0x4488ff,
                    roughness: 0.3
                });
                
                for (const p of points) {
                    const isCenter = (p[0] === 0 && p[1] === 0 && p[2] === 0);
                    const isVE = veNeighbors.some(v => v[0] === p[0] && v[1] === p[1] && v[2] === p[2]);
                    
                    // Only show center and VE neighbors
                    if (!isCenter && !isVE) continue;
                    
                    let mat = defaultMat;
                    if (isCenter && highlightCenter) mat = centerMat;
                    else if (isVE && highlightVE) mat = veMat;
                    
                    const sphere = new THREE.Mesh(sphereGeom, mat);
                    sphere.position.set(p[0], p[1], p[2]);
                    mainGroup.add(sphere);
                }
            }
            
            // Draw cubic unit cells - enough to cover the VE around origin
            // The VE neighbors are at (±1, ±1, 0) permutations
            // So we need cells covering from -2 to +2 in each direction
            // Cell corners at (-2,-2,-2), (-2,-2,0), (-2,0,-2), etc.
            
            if (showCell) {
                const s = 2; // cell side length in our coordinates
                
                // Draw 8 unit cells: corners at combinations of (0,-2) for each axis
                const cellCorners = [
                    [0, 0, 0],
                    [-s, 0, 0],
                    [0, -s, 0],
                    [0, 0, -s],
                    [-s, -s, 0],
                    [-s, 0, -s],
                    [0, -s, -s],
                    [-s, -s, -s]
                ];
                
                const cellMat = new THREE.LineBasicMaterial({ color: 0xff4444, transparent: true, opacity: 0.6 });
                
                for (const corner of cellCorners) {
                    const [cx, cy, cz] = corner;
                    const cubeEdges = [
                        // Bottom face
                        [[cx,cy,cz], [cx+s,cy,cz]], [[cx+s,cy,cz], [cx+s,cy+s,cz]], 
                        [[cx+s,cy+s,cz], [cx,cy+s,cz]], [[cx,cy+s,cz], [cx,cy,cz]],
                        // Top face
                        [[cx,cy,cz+s], [cx+s,cy,cz+s]], [[cx+s,cy,cz+s], [cx+s,cy+s,cz+s]], 
                        [[cx+s,cy+s,cz+s], [cx,cy+s,cz+s]], [[cx,cy+s,cz+s], [cx,cy,cz+s]],
                        // Vertical edges
                        [[cx,cy,cz], [cx,cy,cz+s]], [[cx+s,cy,cz], [cx+s,cy,cz+s]], 
                        [[cx+s,cy+s,cz], [cx+s,cy+s,cz+s]], [[cx,cy+s,cz], [cx,cy+s,cz+s]]
                    ];
                    
                    for (const [p1, p2] of cubeEdges) {
                        const geom = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(...p1), new THREE.Vector3(...p2)
                        ]);
                        mainGroup.add(new THREE.Line(geom, cellMat));
                    }
                }
            }
            
            // VE edges
            if (showVEEdges) {
                const edgeMat = new THREE.LineBasicMaterial({ color: 0x44ff44 });
                for (const [i, j] of veEdges) {
                    const geom = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(...veNeighbors[i]),
                        new THREE.Vector3(...veNeighbors[j])
                    ]);
                    mainGroup.add(new THREE.Line(geom, edgeMat));
                }
            }
        }
        
        rebuild();
        
        document.querySelectorAll('input').forEach(el => {
            el.addEventListener('change', rebuild);
            el.addEventListener('input', rebuild);
        });
        
        // Mouse controls
        let isDragging = false;
        let prevMouse = { x: 0, y: 0 };
        
        container.addEventListener('mousedown', e => {
            isDragging = true;
            prevMouse = { x: e.clientX, y: e.clientY };
        });
        
        container.addEventListener('mousemove', e => {
            if (isDragging) {
                mainGroup.rotation.y += (e.clientX - prevMouse.x) * 0.01;
                mainGroup.rotation.x += (e.clientY - prevMouse.y) * 0.01;
                prevMouse = { x: e.clientX, y: e.clientY };
            }
        });
        
        container.addEventListener('mouseup', () => isDragging = false);
        container.addEventListener('mouseleave', () => isDragging = false);
        
        container.addEventListener('wheel', e => {
            e.preventDefault();
            camera.position.multiplyScalar(1 + e.deltaY * 0.001);
        }, { passive: false });
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        function animate() {
            requestAnimationFrame(animate);
            if (document.getElementById('autoRotate').checked && !isDragging) {
                mainGroup.rotation.y += 0.003;
            }
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>
